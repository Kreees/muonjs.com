h3 Hello, wolrd!
p
    | В данном разделе, пользуясь средствами фреймворка
    b  muon.js
    |  мы создадим первое пробное приложение.
    |  В дальнейшем во всех главах этого и остальных разделов мы будем использовать его для демонстрации
    |  возможностей библиотеки, а также обсуждения проблем построения SAP.
h4(data-focus='start') Инициализация и запуск приложения
p Первым шагом инициализации проекта Node.js является
    |  создание в корневой директории проекта файла
    b  package.json
    | , в котором дается его описание, включая название, назначение, автора, версию и т.д.
    |  (данная информация нужна главным образом для публикации проекта в&nbsp;
    |  реестре пакетов NPM), а также приводится список зависимостей.
p Для инициализации проекта в библиотеку
    b  Muon.js
    |  включена программа
    b  m-init
    | , которая сама создает и заполняет директорию проекта необходимыми исходными подкаталогами и файлами, в соответствие с требованиями
    |  библиотеки, а также создает заготовку
    b  package.json
    | .
p Для запуска
    b  m-init
    |  нам необходимо предварительно выполнить глобальную установку библиотеки
    b  muon
    | :
div.code
    span foo:~$ npm install -g muon
br
div.mark
    h5 Внимание!
    p Если вы устанавливали Node.js так, как это описано в данном разделе выше, то глобальная установка пакетов не
        |  потребует прав администратора. В том случае, если вы воспользовались готовым APT пакетом, либо разместили
        |  библиотеку вне домашней директории, то для выполнения данного действия вам возможно потребуются права администратора.
        |  В этом случае команду, указанную выше, вам необходимо выполнить через
        b  sudo
        | .
    p Из соображений безопасности система
        b  sudo
        |  в последних версиях дистрибутивов подменяет переменные окружения на стандартные, поэтому команды
        b  npm
        |  может не оказаться среди директорий, обозначенных в
        b  $PATH
        | . В этом случае вам необхохдимо будет вызвать npm, указав полный путь до исполняемого файла.
p  С этого момента мы займемся разработкой нашего первого приложения. В качестве Hello, world!
    |  проекта в веб разработке принято брать приложения типа аля'Twitter или планировщики заданий. В рамках этой главы
    |  нам конечно же не удастся создать законченный продукт. Пока я ограничусь тем, что покажу, как инициализировать
    |  проект и создать первые элементы интерфейса. Предлагаю в рамках данного туториала создать календарь с элементами
    |  планировщика заданий. Называться наш проект будет
    b  SuperCalendar
    | .
p Работа m-init крайне проста. Для инициализации проекта необходимо вызывать программу, передав ей единственный аргумент -
    |  название проекта.
div.code
    span foo:~$ m-init SuperCalendar
    br
    span ...
    br
    span Complete!
    br
    span foo:~$ cd SuperCalendar
p В ходе работы программы будет создана директория, в которую будут скопированы файлы
    b  шаблонного
    |  проекта. Последним этапом по созданию проекта является установка зависимостей. В файле
    b  package.json
    |  только что созданного проекта вы обнаружите, что в число зависимостей добавлен только один модуль
    b  muon
    | , который собственно и отвечает за работу всего приложения. Установка зависимостей выполняется с помощью метода
    b  npm install
    | :
div.code
    span foo:~/SuperCalendar$ npm install
    br
    span npm http GET https://registry.npmjs.org/muon
    br
    span npm http 200 https://registry.npmjs.org/muon
    br
    span ...
p После того как npm установит все зависимости мы сможем запустить наш веб-сервер.
    |  основным исполняемым файлом проекта является файл
    |  app.js
    | , который находится в корневой директории проекта.
div.code
    span foo:~/SuperCalendar$ m-start
    br
    span Server started in development mode, listening on 0.0.0.0:8000 address.
    br
    span ...
p По умолчанию сервер прослушивает адрес 0.0.0.0 на
    |  8000-м порту. Указав в браузере данный адрес вы увидете приветственную страницу проекта.
div.tutor_img
    img(data-src='hello_screenshot.png')
p Наш проект готов. В данном случае мы получили заготовку будущего сайта, которую можно и нужно править.
h4(data-focus='dir_struct') Структура папок проекта
p Просматривая директорию проекта вы обнаружите приблизительно следующую структуру:
div.code(style='float: left; width: 230px; margin-right: 20px')
    b client/
    br
    span || assets/
    br
    span |--| ...
    br
    span || packages/
    br
    b |--| application/
    br
    span |----| ...
    br
    b |----| views/
    br
    b |----| package.js
    br
    b || index.html
    br
    b server/
    br
    span || app/
    br
    span |--| controllers/
    br
    span |--| decorators/
    br
    span |--| initialisers/
    br
    span |--| middleware/
    br
    b |--| models/
    br
    span |--| helpers/
    br
    span lib/
    br
    span || plugin_loader.js
    br
    span tmp/
    br
    b app.js
    br
    b config.json
    br
    span package.json
    br
    span README.md
p Если вы занимались разработкой веб-сайтов на других фреймворках, то заметите ряд общих черт, например, наличие в клиентской части файла
    b  index.html
    |  и папки
    b  assets
    |  в которой вполне ожидаемо будут размещаться статичные файлы приложения, в частности CSS- и JS-файлы, изображения,
    |  шрифты и т.д. В серверной части приложения вы обнаружите набор каталогов, содержащих описание
    b  моделей
    |  данных и сопутсвующих им модулей.
p Из наиболее превычных можно также выделить файлы
    b  package.json
    | ,
    b  app.js
    |  и
    b  README.md
    | .
p Про файл <b>package.json</b> я уже писал выше. Он отвечает за описание вашего Node.js проекта, включая внешние зависимости, а также информацию,
    |  необходимую для публикации проекта в реестре NPM.
    |  Файл <b>app.js</b> является точкой входа в проект. В шаблонном варианте данный файл содержит код, подгружающий библиотеку
    b  muon
    | , создающий экземпляр сервера и запускающий его на прослушивание.  Вполне очевидно, что файл <b>README.md</b> предназначен для хранения краткого описания вашего проекта. Данный файл будет
    |  автоматически учтен при публикации на github'e и других аналогичных сервисах.
p Помимо данных файлов в корне проекта находится файл
    b  config.json
    | , который содержит информацию, необходимую для инициализации muon-проекта. Просматривая содержимое данного файла,
    | , вы найдете там переменные, хранящие адрес и порт, к которым выполняется привязка веб-сервера, базы данных, стандартную локаль проекта,
    |  а также перечень muon-плагинов, из которых будет собрано приложение (более подробно о плагинах в структуре muon-проекта
    |  будет рассказано в разделе туториала, посвященной серверной части библиотеки).
p Оставшиеся неописанные директории - <b>lib</b> и <b>tmp</b>
    |  - имеют служебное значение. В первой хранится JS-модуль, ответственный за формированние плагинной структуры проекта.
    |  Директория tmp предназначена для размещения временных файлов, а также файлов, загруженных на сервер из Интернета.
p Из представленной структуры видно четкое разделение приложения на <b>серверную</b> и <b>клиентскую</b> часть. В классических фреймворках
    |  с рендерингом старниц на серверной стороне (Rails, Django, Yii), формирование клиента было полностью заботой сервера -
    |  рендеринг страниц осуществлялся с каждым запросом наравне с обращением к базе данных, обработкой данных моделей и т.д.
    |  В одностраничных приложениях сервер безусловно также принимает участие в генерации клиента (далее мы увидим, как это происходит),
    |  однако выгрузка HTML-кода клиента в браузер осуществляется не с каждым запросом, а только один раз при первом запросе (в виде одного большого <b>index.html</b> файла).
    |  Далее уже на стороне браузера клиент определяет, какой именно запрос был сделан, и выполняет все сопутствующие ему
    |  действия. Все остальные запросы из загруженного клиента к серверу сводятся (в упрощенном варианте) к выборке данных моделей в сыром виде (JSON-формате).
p
    | Из этого описания хорошо видно, как сильно оказываются развязаны клиентская и серверная часть приложения. Это
    |  одно из наиболее значимых преимуществе SAP, так как отделив сервер от клиента, у нас появляется возможность менять поведение клиента
    |  и интерфейс, не беспокоясь о вопросах целостности данных, безопасности и&nbsp;т.&nbsp;д. (при этом предполагается, что сервер уже
    |  обеспечивает все эти свойства приложения). Данная особенность в свою очередь упрощает процесс разработки под разные таргетинговые платформы
    |  и аудитории, что есть большой плюс в коммерческой разработке (более подробно о преимуществах и недостатках SAP мы поговорим в следующей главе).
p Возвращаясь к содержанию проекта, таким образом становится понятен смысл разделения структуры проекта на две основные составляющие
    |  - директории <b>client</b> и <b>server</b>.
h4 Структура клиента
h5 Декомпозиция. Виджеты.
p <b>Клиентская</b> составляющая хранит в себе все то, что в конечном счете в том или ином виде будет показано в окне браузера.
    |  Одностраничное приложение безусловно можно написать в одном единственном HTML-файле, однако, обеспечить более менее значимую сложность и функциональность
    |  приложения будет непросто. По этой причине одной из наиболее критичных задач построения клиента является <b>структуризация</b>
    |  и <b>декомпозиция</b> клиента.
p Для удобства разработки <b>толстый клиент</b> может быть разбит на части и представлен в виде
    |  совокупностей взаимодействующих элементов интефрейса - <b>виджетов</b>. Те, кто знаком с разработкой UI для
    |  настольных прилжоений (MFC, VCL, QtGui и т.д.), помнят назначение виджетов (widgets). В Muon.js интерфейс пользователя
    |  строится как "конструктор" из вложенных частей, которыми виджеты и являются.
p Основной задачей виджетов, как например в случае с C++ библиотекой <a href='http://qt-project.org' target='new'>QtGui</a>,
    |  является формирование законченных логических элементов интерфейса, выполняющих одну конкретную задачу. Это могут быть
    |  дата пикеры, прогрес бары, формы ввода, диалоговые окна и т.д. В общем случае я считаю целесообразно выводить
    |  все более-менее значимые <b>паттерны</b> пользовательского интерфейса в отдельные виджеты, тем самым обеспечивая повторное
    |  использование программного кода.
p Более подробно существующих паттернов UI и UIX в целом я коснусь позже. Однако, считаю необходимым
    |  указать на наиболее важные и распространенные паттерны, которые реализуются в каждом веб-сайте.
p Первым из них конечно же являестя <b>веб-страница</b>. Под веб-страницей я понимаю некоторый раздел сайта (или часть веб-документа), который содержит
    |  логически связанный законченный набор информации, одновременно отображющейся в окне браузера, и которому, как правило, соответствует уникальный <b>URL</b>. На примере данного
    |  сайта, текущей является страница, начиная с <a data-hover='h3:first-child'>H3</a> заголовка "Hello, World!" и вплоть до самого конца данного текста.
    |  В то же время следует отметить, что в документе присутствуют элементы, которые нельзя отнести ни к одной странице, такие как темный <a data-hover='.navbar'>navbar</a>
    |  вверху с надписью MUONAPPS и номером версии на противоположной стороне, а также основные <a data-hover='.main-pills'>ссылки</a> на разделы сайта.
    |  Данные элементы не принадлежат ни одной странице и являются общими для всего сайта, что наводит на мысль, что, не смотря на свою значимость,
    |  <b>страница</b> не является самым главным <b>топовым</b> элементом (виджетом) сайта. Так мы получаем второй
    |  наиболее значимый паттерн пользовательского интерфейса. Я не нашел ему прямого названия, поэтому в структуре виджетов элементам
    |  данного типа было данно название, ни много ни мало, <b>application</b>.
p Application по сути - это связующее звено всего сайта, которое
    |  является контейнером для его разделов (страниц). Необходимость контейнера обусловлена как раз наличием постоянных элементов
    |  интерфейса, к которым как правило относятся header и footer страницы, навигационные ссылки, площадки для рекламных баннеров
    |  и т.д. Безусловно, если данные элементы в интерфейсе сайта статичны и не зависят от текущего содержания (отображаемой страницы),
    |  генерировать их повторно нет смысла. Значительно проще выделить в составе виджета изменяемую область, и по мере необходимости
    |  размещать в ней виджеты-страницы, параллельно подменяя содержимое адресной строки браузера.
div.tutor_img
    img(data-src='app_page_struct.png')
p Наш <b>супер календарь</b> имеет ровно такую же структуру. Убедиться в этом вы можете, указав произвольный путь в рамках URL, например,
    |  <b>localhost:8000/wrong_page</b>. В ответ вы увидете страницу с заголовком, но уже без приветствия. Очевидно, что
    |  заголовок и текстовый логотип принадлежат виджету application, в то время как содержательный текст относится к странице.
div.tutor_img
    img(data-src='wrong_page.png')
p Как я уже сказал, и страницы, и application являются лишь виджетами среди прочих в структуре всего клиента. Помимо данных виджетов
    |  вы можете создавать другие виджеты по вашему усмотрению. Некоторые из них отвечают за структуру сайта (страницы и application к ним относятся), другие
    |  отвественны за представление (отображение) данных или коллекций данных, хранящихся на сервере. В общем же случае виджеты могут иметь абсолютно произвольное
    |  функциональное, информационное, визуальное и структурное наполнение.
    |  Все виджеты хранятся в директория <b>views</b> (см. <a data-route='/general/hello_world/dir_struct'>структуру папок</a>).
p Причина, по которой данная директория имеет имя <b>views</b>, а не
    |  <b>widgets</b>, заключается в том что в веб-программировании имя <i>View</i> являет общепринятым. Взято оно из абривиатуры MVC (Model View Controller), где
    |  View имеет смысл <b>представления</b> данных. Исторически так сложилось, что термином View начали называть все, что ответственно за динамическое
    |  отображение данных, в том числе шаблоны. В частности библиотека <a href='http://expressjs.com' target='new'>express.js</a>, на базе которой работает серверная часть
    |  библиотеки, использует переменную окружения "views", для хранения пути к файлам-шаблонам. <a href='http://backbonejs.org' target='new'>Backbone.js</a>,
    |  взятая за основу клиетской части, в свою очередь содержит класс объектов Backbone.View, предназначенный для динамического
    |  отображения произвольных данных на клиенте (именно этот класс лег в основу описываемых виджетов). Можно привести
    |  еще множество примеров, где для генерируемых элементов на клиенте используется термин View, хотя сам я с ним не до конца согласен.
p Прежде чем я перейду непосредственно к описанию виджетов, которые в определенной степени являются основой всего клиента,
    |  я опишу второй метод структуризации клиента. Им являются пакеты.
h5 Пакеты.
p В структуре веб-сайтов и приложений очень часто присутствуют <b>разделы</b>, отвечающие за одну конкретную (как правило крупную) задачу.
    |  Хорошим примером такого раздела может быть 'админка' сайта. В случае социальных сетей это также могут быть разделы, отвественные за
    |  обмен сообщениями, работу с медиа-данными (аудио-видео), систему блогов и т.д. - примеров можно найти очень много.
    |  В целом для любого более или менее крупного сайта логическое деление на подразделы вполне естественно.
p Когда я начинал заниматься разработкой библиотеки и сайтов на ее основе, я достаточно быстро пришел к выводу, что виджеты,
    |  целесообразно группировать по назначению, так как это значительно упрощает процесс, позволяя лучше концентрироваться на, пускай крупной,
    |  но все же частной задаче. Так я пришел к необходимости формирования <b>пакетов</b> виджетов. Фактически пакет представляет
    |  собой небольшой сайт, со своей логической структурой, со своими страницами и application-виджетом (хотя это не является обязательным),
    |  который может быть включен в состав другого, более крупного сайта.
div.tutor_img
    img(data-src='complex_app_page_struct.png')
p Использование пакетов для структурирования кода клиента имеет целый ряд преимуществ. Помимо высокой модульности приложения,
    |  вы получаете возможность <b>повторного использования кода</b>. В вебе существует большое количество типичных задач, решая которые,
    |  в каждом отдельном случае нередко, к сожалению, приходится изобретать велосипед. Пример с разделом администрирования сайта
    |  в данном случае очень показателен. Так же это могут быть встроенные блоги и форумы, корзины Интернет-магазинов,
    |  системы документирования веб-проектов и т.д. Однажды созданное решение любой из этих задач может быть повторно использовано
    |  (перенесено) в других проектах.
p <b>Вторым</b> преимуществом пакетного формирования клиента является возможность загрузки частей сайта <b>по требованию</b>.
    |  Сама возможность существования одностраничных приложений обусловленна стремительным ростом скорости работы компьютеров в целом и Интернет-
    | браузеров в частности. И все же, несмотря на это, веб-приложения и веб-сайты значительно уступают в производительности
    |  нативным настольным приложениям (особенно эта разница ощутима на мобильных платформах). Ко всему, производительность
    |  кода на странице сайта во многом зависит от содержания этой страницы, в том числе от сложности структуры DOM-документа,
    |  объема кода и ряда других параметров. Использование пакетов дает возможность загружать код виджетов по мере необходимости, экономя
    |  при этом память и не перегружая DOM-структуру веб-документа, когда в этом нет нужды.
p <b>Третьим</b> существенным плюсом использования пакетов я вижу перспективу интеграции сервисов использующих единую систему
    |  пакетов между собой. <b>Система пакетов</b> подразумевает единый интерфейс выгрузки данных пакета клиента независимо от того,
    |  кто является клиентом. Даже если абстрагироваться от Muon.js, наличие стандартного механизма выгрузки части клиентского кода намного
    |  упростило бы интеграцию различных веб-сервисов, таких как виджеты социальных сетей, платежных систем и т.д.
p Реализация всех этих и других возможностей будет описана позже в разделе туториала, посвещенном клиентской части библиотеки. А пока что
    |  мы ограничемся тем, что пакеты  позволяют нам добиться более стройной структуры приложения и упорядочить клиентский код.
p Идея пакетов в Muon.js является одной из центральных. Проявляется это в том, что в структуре сайта у вас всегда присутствует
    |  как минимум один пакет, имеющий название <b>application</b>, и это является обязательным. Сами пакеты размещаются в директории <b>client/packages</b>.
    |  Во главе каждого пакета лежит файл <b>package.js</b>, описывающий
    |  содержание и поведение пакета, в частности систему <b>роутинга</b> в рамках пакета и сопутствующие обработчики запросов, метод
    |  <b>инициализации</b> пакета и <b>middleware</b>.
div.mark
    h5 JS vs. JSON
    p Внимательный читатель наверняка обратил внимание, что файл с описанием пакета имеет расширение <b>js</b>, а не <b>json</b>.
        |  Причина, по которой я выбрал именно такой способ описания, кроется в необходимости анализировать содержимое
        |  данного файла в процессе генерации самого пакета на стороне сервера. Если вы посмотрите содержимое <b>package.js</b>,
        |  то увидите, что пакет экспортирует переменную <b>exports</b>, как это принято в <b>CommonJS</b>. Помимо этого, в состав
        |  пакета входят определения функций (обработчиков роутера, инициализатора и т.д.), что не допускается в рамках JSON-
        | протокола.
p К этому моменту вам должна быть полностью ясна представленная структура папок в разделе client'а. И следовательно, мы можем на время
    |  отвлечься от нудной теории и перейти к описанию непосредственно <b>виджетов</b> и редактированию нашего сайта.
h5 Сервер
p

h4(data-focus='deploy') Советы по деплою
p
    | В целом, несмотря на заявление, что muon.js не является зрелым фреймворком, на его базе вполне может быть построен
    | работоспобный сайт с вполне неплохой производительностью