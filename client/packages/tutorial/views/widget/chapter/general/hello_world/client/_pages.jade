h5.title#pages Страницы
p Думаю, самое время попробовать добавить несколько страниц в наш календарь. Добавление страниц в приложение состоит из трех шагов: в первую очередь необходимо задать адреса
    |  по которым эти страницы будут доступны на сайте; во-вторых, создать файлы, в которых мы опишем содержание (верстку) создаваемых страниц.
    |  Последнее, что мы должны сделать, - это обеспечить возможность перехода между страницами, добавив соответствующие ссылки на них в приложение.
p Предположим, что для нашего календаря потребутся следующие страницы:
ul
    li страница выбора даты,
    li страница просмотра почасового рассписания на день,
    li страницы добавления, просмотра и редактирования задач на день (заметок).
p Первым делом нам необходимо зарегистрировать пять различных путей на нашем сайте. Это:
ul
    li
        i /
        |  - главный экран приложения
    li
        i /calendar
        |  - выбор даты
    li
        i /day_schedule
        |  - отображение расписания на день
    li
        i /note
        |  - показ заметки
    li
        i /note/add
        |  - добавление заметки
    li
        i /note/edit
        |  - редактирование заметки
p Для этого нам необходимо отредактировать содержимое файла
    strong  /client/packages/application/package.js.
    |  Данный файл выполняет роль дескриптора клиентского приложения (точнее одного из его пакетов - об этом будет
    |  рассказано далее). В исходном состоянии он должен выглядеть примерно так:
p: strong /client/packages/application/package.js:
pre.prettyprint
    | module.exports = {<br>
    |   useAppLayout: true,<br>
    |   pages: ["*"],<br>
    |   models: ["*"],<br>
    |   middleware: [],<br>
    |   routes: [<br>
    |       {<br>
    |           route: ""<br>
    |       },<br>
    |       {<br>
    |           route: "*a",<br>
    |           page: "error"<br>
    |       }<br>
    |   ],<br>
    |   surrogate: {}<br>
    | }
p Содержание файла напоминает <a target='new' href='http://en.wikipedia.org/wiki/Asynchronous_module_definition'>AMD нотацию</a>: дескриптор клиента (пакета) помещается в переменную <strong>module.exports</strong>.
    |  По содержанию файла становится вполне очевидно, что нас интересует атрибут <strong>routes</strong>. В данном случае
    |  клиент уже содержит два объявленных пути (корень "", и произвольный путь "*a"), нам же необходимо привести содержимое атрибута к следующему виду:
pre.prettyprint
    | routes: [<br>
    |     { route: "" },<br>
    |     { route: "calendar" },<br>
    |     { route: "day_schedule" },<br>
    |     { route: "note" },<br>
    |     { route: "note/add" },<br>
    |     { route: "note/edit" },<br>
    |     {<br>
    |         route: "*a",<br>
    |         page: "error"<br>
    |     }<br>
    | ]<br>
div.mark
    h5 Клиентский роутинг
    p Те, кто занимался разработкой SPA, знают о библоитеке <strong>Backbone</strong>,
        |  которая лежит в основе Muon. Muon расширяет объект маршрутизации <strong>Backbone.Router</strong> и реализует немного
        |  иной подход к построению дерева маршрутов на клиенте. В то же время синтаксис для определения маршрута
        |  полностью соответствует синтаксису, используемому в Backbone: Вы можете использовать
        |  как прямые записи в виде строк, так и упрощенные регулярные выражения для указания в маршруте опциональных параметров.
        |  В данном случае запись '*a' соответствует любому набору символов, включая символ слэш '/'.
        |  Подробней о маршрутах в Backbone Вы можете узнать из <a target='new' href='http://backbonejs.org/#Router'>документации</a> Backbone.
    p Заметьте также, что в отличие от атрибута <strong>routes</strong>, задаваемого при создании объекта <strong>Backbone.Router</strong>,
        |  в нашем случае этот атрибут является не объектом, а массивом.
    p Более подробно работа системы клиентской маршрутизации в Muon будет рассмотрена в соответствующих главах данного туториала, а также
        |  также отдельного туториала, посвященного разработке под клиент.
p Следующее, что нам требуется, -  это добавить файлы с разметкой страниц в состав клиента. Для этого в директории
    strong  /client/packages/application/layout/page/
    |  необходимо создать дополнительно три директории с именами <strong>calendar</strong>, <strong>day_schedule</strong> и
    |  <strong>note</strong>, а в созданной директории <strong>note</strong> еще две: <strong>add</strong> и <strong>edit</strong>.
    |  В каждой из созданных директорий нужно создать HTML- и CSS-файлы с соответствующими именами. Например <strong>calendar.html</strong>.
    |  В конечном счете относительно указанной директории у Вас должна получиться следующая структура файлов и папок.
ul
    li ./calendar/calendar.html
    li ./calendar/calendar.css
    li ./day_schedule/day_schedule.html
    li ./day_schedule/day_schedule.css
    li ./note/note.html
    li ./note/note.css
    li ./note/add/add.html
    li ./note/add/add.css
    li ./note/edit/edit.html
    li ./note/edit/edit.css
p Мы не брали в расчет главную страницу сайта, относящуюся к корневому адресу "", так как она уже присутствует в директории
    |  под названием <strong>index</strong>.
p Думаю, должно быть понятно, что содержание файлов <strong>calendar/calendar.html</strong> и <strong>calendar/calendar.css</strong>
    |  отвечает за содержание и внешний вид (стиль) объявленной страницы <strong>calendar</strong>. Тоже самое верно и для остальных созданных страниц.
p Чтобы не тратить слишком много времени, мы продолжим работать только с двумя страницами: <strong>index</strong> и <strong>calendar</strong>.
    |  Файлы верстки HTML будут иметь следующее содержание:
p: strong /client/packages/application/layout/page/index/index.html:
title = "<h1>Welcome to the Super Calendar</h1>"
data = "<p>This is the main page of the Calendar</p>"
pre.prettyprint.lang-html
    = title
    br
    = data
p: strong /client/packages/application/layout/page/calendar/calendar.html:
title = "<h1>Date picker page</h1>"
data = "<p>We will be able to choose a date on this page soon</p>"
pre.prettyprint.lang-html
    = title
    br
    = data
div.mark
    p В директории, соответствующей главной странице, вместо HTML и CSS файлов размещены шаблонные файлы с раширениями
        |  <strong>.jade</strong> и <strong>.less</strong>. Muon поддерживает ряд шаблонизаторов, упрощающих написание HTML и CSS кода,
        |  в том числе <a target='new' href='http://jade-lang.org'><strong>Jade</strong></a> и <a target='new' href='http://lesscss.org'><strong>Less</strong></a>.
        |  Если Вы не знакомы с синтаксисом этих шаблонизаторов, вы можете заменить расширения существующих файлов на
        |  <strong>.html</strong> и <strong>.css</strong> и использовать стандартный синтаксис.
p Файлы index.css и calendar.css будут использовать единый стиль и должны иметь следующий вид:
p
    strong /client/packages/application/layout/page/index/index.css:
    br
    strong /client/packages/application/layout/page/calendar/calendar.css:
pre.prettyprint.lang-css
    | h1 {<br>
    |   color: gray;<br>
    |   font-size: 16px;<br>
    | }<br>
    br
    | p {<br>
    |   font-size: 13px;<br>
    | }
p Для того, чтобы просмотреть результат изменений нам достаточно открыть страницы localhost:8000 и
    |  localhost:8000/calendar, и, если все было сделано правильно, Вы увидете следующее:
div.tutor-img.shadow
    img(data-src='page_index.png')
div.tutor-img.shadow
    img(data-src='page_calendar.png')
p Последний момент - нам остается разместить линки на наши страницы и обеспечить навигацию между ними. Лучше всего
    |  сделать это в заголовке сайта (header), в том месте, где размещена надпись "The hardest piece of work has passed!". Как я говорил ранее,
    |  заголовок не относится ни к одной из объявленных страниц сайта, а размещается в структурном элементе <strong>appliation</strong>.
    |  Данный элемент является единственным во всей структуре сайта, и файлы с его версткой и стилями размещены в директории
    strong  /client/packages/application/stack/application
    | . Содержание файлов должно быть следующим:
p: strong /client/packages/application/stack/application/application.html:
title = "<h2>Super Calendar</h2>"
ul = "<ul>"
li_main = "     <li><a data-route='/'>Main</a></li>"
li_calendar = "     <li><a data-route='/calendar'>Calendar</a></li>"
ul_close = "</ul>"
target = "<div id='target'></div>"
pre.prettyprint.lang-html
    = title
    br
    = ul
    br
    = li_main
    br
    = li_calendar
    br
    = ul_close
    br
    = target
p: strong /client/packages/application/stack/application/application.css:
pre.prettyprint.lang-css
    | & {<br>
    |   padding: 50px;<br>
    | }<br>
    br
    | ul li {<br>
    |   display: inline-block;<br>
    |   padding: 15px;<br>
    | }<br>
    br
    | ul li:hover {<br>
    |   background-color: rgb(66,139,202);<br>
    | }<br>
    br
    | ul li:hover a {<br>
    |   color: white;<br>
    |   text-decoration: none<br>
    | }<br>
p После перезагрузки Вы должны увидеть полностью оформленную страницу календаря:
div.tutor-img.shadow
    img(data-src='page_with_routes.png')
p Покликав на созданные гиперссылки вы увидете, что подменяется только содержимое, находящееся под ними, при этом
    |  сама страница не перезагружается (убедиться в этом можно воспользовавшись отладочной консолью браузера).
    |  Таким образом мы добились того, что на Супер Календарь стал немного походить на одностраничное веб-приложение.
h5 Разбор полетов
p Прежде, чем закончить работу со страницами, следует дать несколько пояснений к тому, что мы только что сделали.
p В первую очередь следует отметить содержание и расположение файлов, описывающих наполнение страниц и элемента application.
    |  Все они находятся в директории <strong>/client/packages/application/views</strong>. Это место в структуре
    |  клиента (и приложения в целом), куда помещаются все создаваемые элементы интерфейса,
    |  Соответственно имя и назначение представлений (в том числе тех, что мы только что создали) определяется их
    |  расположением относительно указанной директории. При этом имя элемента интерфейса application имеет полное
    |  название <strong>application_stack</strong>, а созданных нами страниц - <strong>index_page_layout</strong>,
    |  <strong>calendar_page_layout</strong> и т.д. В формировании имени представления участвуют только имена вложенных папок,
    |  в то время как имена файлов могут иметь произвольное значение (о нюансах мы поговорим позже). Ожидается, что
    |  в папке, определяющей одно из представлений, может находиться три типа файлов: файл <strong>верстки</strong>, файл <strong>стилей</strong> и файл,
    |  описывающий <strong>логику поведения</strong> элемента интерфейса (HTML, CSS и JS соответственно), хотя наличие всех этих файлов
    |  опционально.
p Вы наверняка заметили наличие некошерного селектора <strong>&</strong> в описании стилей <strong>application_stack</strong>.
    |  Файл стилей application.css ответственен за оформление конкретно данного элемента интерфейса, а определенные в нем стили
    |  относительны и применяются не ко всему документу, а только к верхнему (корневому) тэгу данного экземпляра представления
    |  и всем нижележащим дочерним тэгам. Чтобы сослаться на тэги <strong>anchor</strong>, размещенные в элементах
    |  (<strong>li</strong>) списка (<strong>ul</strong>),
    |  следует указать селектор:
pre.prettyprint.lang-css ul > li > a
p Он будет соответствовать любой гипперсылке, вложенной в список ul->li где угодно в рамках представления application_stack
    |  и, как следствие, в рамках всего документа (так как application_stack является обрамлением для всего веб-приложения).
    |  Следовательно, чтобы сослаться непосредственно на корневой тэг элемента, либо тэг, являющийся непосредственно
    |  дочерним для него, нужен специальный селектор (служебное слово), которые бы библиотека воспринимала
    |  соотвтетсвующим образом. В данном случае, таким селектором является символ <strong>&</strong>. В свою очередь
    |  запись:
pre.prettyprint.lang-css & { padding: 50px }
p означает, что правило <strong>padding</strong> будет применено к тэгу, лежащему в основе данного представления <strong>application_stack</strong>.
p Последним неразъясненным моментом остались гипперссылки, а точнее способ указания маршрута для навигации между старницами.
    |  Наверняка Вы заметили, что вместо стандартного атрибута <strong>href</strong>, был использован атрибут
    |  <strong>data-route</strong>, в тоже время сам тэг <strong>anchor</strong> ведет себя как полноценная ссылка, и если
    |  проинспектировать элемент в консоли браузера, можно увидеть, что атрибут <strong>href</strong> установлен и имеет
    |  правильное значение. Сделано это для того, чтобы библиотека могла распознавать нажатия на внутренние ссылки приложения,
    |  и вместо полноценной перезагрузки страницы обращалась к объекту <strong>History</strong> браузера. В тоже время
    |  ссылка имеет свой адрес, и поэтому она может быть использована как любая другая ссылка, в частности быть открыта в новой
    |  вкладке, ее адрес может быть скопирован через контекстное меню и т.д.