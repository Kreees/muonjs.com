h5.title#MVC MVC
p Начиная разговор о работе сервера нельзя не затронуть описание механизма, которому полностью подчинена его работа.
    |  Даже несмотря на то что пока нам предстоит лишь создать несколько сущностей данных и показать, как происходит
    |  базовое клиент-серверное взаимодействие, не лишним будет иметь представление о том, из чего складывается общая логика сервера.
p В основе сервера Muon лежит структурный шаблон <a href='http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller' target='new'>MVC</a> (Model, View, Controller - Модель, Представление, Контроллер), который
    |  очень популярен и активно используется в веб-программировании. Те, кто знаком с ним знаком, могут сразу перейти
    |  к следующей главе, для остальных же, я далее постараюсь кратко описать содержание данного шаблона, а также указать
    |  основные нюансы его реализации в библиотеке.
p <strong>MVC</strong> - это структурный шаблон, определяющий способ организации программного кода и выделяющий три основных структурных паттерна
    |  в составе приложения: <strong>модель</strong>, <strong>представление</strong> и <strong>контроллер</strong>. Как обычно бывает в случае с распространенными
    |  парадигмами программирования, существует несколько интерпретаций относительного того, за что отвечает каждая из букв в аббревиатуре (это особенно
    |  характерно для веба). Однако, в большинстве случаев распределение обязанностей между данными паттернами оказывается следующим:
ul
    li <strong>Модели</strong> - составляющая, которая реализует в себе суть и бизнес логику приложения,
        |  определяет его содержательную часть, к которой в первую очередь относятся типы данных (пользовательские классы) и их взаимные ассоциации. Помимо этого
        |  модель может включать в себя указания, как именно она должна реагировать на внешние воздействия (в нашем случае входящие HTTP-запросы) и
        |  и как они могут влиять на состояние системы.
    li <strong>Преставления</strong> - решают задачу визуализации данных моделей для того, чтобы пользователи приложения
        |  (в том числе другие програмы) могли адекватно интерпретировать состояние моделей данных, а также
        |  через <strong>контроллер</strong> или другие <strong>преставления</strong> менять его. Визуализация данных в данном случае не означает обязательное использование
        |  графики и/или пользовательского интерфейса (в обычном понимании), в данном случае правильнее было бы говорить о формате данных, пригодном
        |  для восприятия пользователями приложения. Например, в случае, когда с приложением или сервисом взаимодействует программный бот, в качестве
        |  такого формата может выступать JSON, YAML или XML, для пользователя веб-сайта, таким форматом как правило является HTML.
    li <strong>Контроллер</strong> принято считать промежуточным звеном между моделью и ее представлением, а также пользователем и моделью. С точки зрения
        |  <a href='http://st-www.cs.illinois.edu/users/smarch/st-docs/mvc.html' target='new'>исходного определения MVC</a>, котороллер выступает в роли
        |  интерпретатора запросов со стороны пользователя, преобразуя их в соответствующие команды моделей данных, с учетом текущего состояния моделей,
        |  прав доступа пользователя, а также других условий, способных повлиять на результат запроса.
        |  Помимо этого контроллер может поддерживать актуальность представлений за счет синхронизации состояния моделей данных с соответствующими
        |  данными представлений.
div.tutor-img(style='padding: 0px 200px;')
    img(data-src='MVC-Process.png')
p Как я уже упоминал выше, в реальности далеко не всегда при проектировании веб-приложений придерживаются чистого определения MVC.
    |  Чаще всего под моделью во многих веб-фреймворках понимают объявленные типы данных и их взимосвязи, которые в большинстве случаев
    |  прямо или косвенно отображаются в структуру базы данных. Под контроллером же понимают механизм роутинга - соотнесения
    |  пользовательских HTTP-запросов с действиями (экшенами - actions), осуществляющими манипулирование моделью, которые также входят в
    |  состав контроллера. Результатом работы экшена обычно является вывод HTML, который отражает текущее состояние всей модели (или всех моделей, кому как нравится)
    |  и таким образом формирует представление.
p Бытует мнение, с которым я полностью согласен, что данная интерпетация MVC является неверной, и в первую очередь потому
    |  что при таком раскладе бизнес логика приложения реализуется не в модели, а в контроллерах (экшенах), таким образом контроллер и модель оказываются неразрывно связаны (или точнее, модель без контроллера
    |  становится неполноценной), чего конечно же быть не должно. Однако, именно такой подход к организации кода оказывается наиболее естественен
    |  (или, возможно, привычен) для веба, так как исторически сложилось, что для каждого типа запроса (маршрута) существует некий метод (контроллер),
    |  который выполняет всю кухню его обработки (главным образом взаимодействие с СУБД, моделью) и формирует итоговый HTML-ответ (представление). Современные библиотеки
    |  позволяют значительно оптимизировать этот процесс, оставляя за экшенами лишь наиболее специфичный для запроса функционал, вынося все наиболее рутинные
    |  и повторяющиеся от запроса к запросу операции в периферийные методы (например, middleware). Тем не менее суть и распределение обязанностей в структуре MVC-сохраняется.
    |  В целом это не имеет определяющей роли при построении приложения, так как во многом остается вопросом терминологии, в то время как главной
    |  задачей любого фреймворка является обеспечение наиболее четкой и прозрачной структуры кода, максимально следующей DRY-парадигме (Don't Repeat Yourself - не повтояйся),
    |  с чем современные фреймворки справляются более чем успешно. Также надо понимать, что изначально идея MVC была сформулирована в далеком 79-м
    |  по отношению к настольным приложениям с оконными интерфейсами на языке Smalltalk, где взаимодействие моделей и представлений (через контроллер)
    |  значительно отличается от взаимодействия браузера и сервера.
p Серверная часть фреймворка Muon также реализует MVC-структуру, и также как и во многих других MVC-фреймворках, бизнеслогика приложения заключена как в модели,
    |  так и в экшенах контроллера. Однако на этом сходство Muon-сервера с классическими фреймворками заканчивается. Как я уже говорил выше, Muon представляет собой API-сервер,
    |  который позволяет клиенту манипулировать данными на сервере, а также поддерживать их актуальность на своей стороне. Происходит это за счет
    |  отправки атомарных AJAX-запросов (один запрос связан с одним из возможных экшенов для конкретной модели данных), при этом для доступа к данным используется автоматически
    |  формируемый API, который учитывает имена моделей, вызываемых экшенов и их взаимные ассоциации. То, как это работает и как это использовать
    |  мы рассмотрим в следующих трех главах.
