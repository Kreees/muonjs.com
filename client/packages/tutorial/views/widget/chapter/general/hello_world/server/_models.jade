h5.title#models Модели данных
p Описание сути MVC в предыдущей главе было достаточно абстрактным, и, чтобы исправить это и лучше понять принцип работы данной парадигмы,
  |  нам следует взять несколько примеров из жизни, что мы сейчас и сделаем в рамках нашего календаря.
p Исходя из существующего определения <strong>модели</strong> следует, что одной из главных предназначений этого паттерна является построение системы понятий, применимых к той области,
  |  в которой предполагается работа приложения. Существует несколько техник, позволяющих достаточно легко определить, какие именно понятия и, соответственно, модели должны
  |  быть включены в состав проекта. Одним из наиболее популярных и эффективных способов, например, является сочинение историй, описывающих некоторую ситуацию или кейс
  |  (usecase) - вариант использования приложения. В данной главе и в туториале в целом описывать истории использования мы не станем, однако, этому вопросу я рекомендую уделить
  |  особое внимание, так как умение проводить грамотный анализ предметной области неплохо помогает при проектировании любых программных систем (не только веб-приложений).
  |  Помочь лучше разобраться в этой теме Вам поможет замечательная <a href='http://www.amazon.com/Object-Oriented-Analysis-Design-Applications-Edition/dp/020189551X' target='new'>книга</a>
  |  Гради Буча, одного из авторов языка UML.
p Я думаю, вполне очевидно, что в качестве моделей данных нам необходимо определить такие понятия как <strong>заметка</strong> и <strong>пользователь</strong>. Заметки мы будем включать в наш календарь
  |  для конкретных дат и составлять из них расписание на день. В свою очередь "пользователь" будет выступать той абстракцией, которая позволит нам разделять заметки,
  |  созданные различными клиентами. В данном случае мы не будем воссоздавать сложную логику классического пользователя веб-сервиса с необходимой регистрацией, сессиями и т.д.,
  |  и ограничимся лишь выделением уникальных пользователей и присваиванием им уникального ID с помощью Cookie.
p Создание новой модели данных в Muon происходит отличным от большинства других фреймворков способом. Как правило определение моделей данных (ровно как контроллеров и т.д.)
  |  происходит путем наследования общего класса моделей, либо одного из существующих его производных, например:
pre.prettyprint.lang-js  > var NewModel = SuperModel.<strong>extend</strong>({ ... });
p Напротив, большинство сущностей в Muon определяется не через прямое выполнение кода (определение нового класса через наследование), а с помощью дескрипторов,
  |  помещенных в определенные участки файловой структуры проекта. Вы уже знаете, что в рамках дерева проекта существует директория <strong>/server/app/models</strong>.
  |  Данная директория предназначена для размещения в ней файлов - JavaScript модулей, которые подключаются к проекту в процессе ее инспектирования библиотекой
  |  (аналогичным образом работают все составляющие сервера). При этом имена и размещение файлов относительно данной директории имеет центральное значение в процессе
  |  именования моделей, аналогично тому как это было в случае с виджетами. В силу того, что модель формируется не явно при наследовании класса, а на основе описания,
  |  файл с дескриптором может быть пустым (экспортирование пустого JavaScript-модуля вернет пустой объект). Поэтому для объявления наших двух моделей нам пока достаточно
  |  создать два файла:
ul
    li /server/app/models/note.js
    li /server/app/models/user.js
p Чтобы проверить работу модели мы можем воспользоваться предоставляемым Muon сервером <strong>веб API</strong>, либо обратиться к средствам библиотеки через интерпретатор.
  |  Работу с веб API мы оставим до следующей главы, а пока воспользуемся классическим методом отладки веб-проектов и попытаемся вручную поработать с моделями данных
  |  с помощью <strong>node</strong>-интерпретатора. Вызов интерпретатора можно выполнить напрямую с помощью команды <strong>node</strong>, либо воспользоваться утилитой <strong>m-console</strong>, входящей в состав
  |  библиотеки. <strong>m-console</strong> является небольшой надстройкой над базовым интерпретатором и лишь добавляет в него автоматическую загрузку окружения проекта Muon из
  |  текущей директории командной строки.
div.mark
    h6 Модели данных и СУБД
    p В данном туториале мы почти не будем говорить о базе данных, так как пока разбираем наиболее общие моменты библиотеки, не вдаваясь в технические детали ее реализации.
        |  В разделе, посвященном окружению, в главе <a data-route='/general/env/db'>База данных</a> я указал на использование <strong>MongoDB</strong> в качестве основной базы данных.
        |  Безусловно, в реальных проектах Mongo далеко не всегда оказывается эффективным решением, в конечном счете необходимость использования другой СУБД может оказаться требование заказчика.
        |  В качестве основы для моделей Muon сервера используется библиотека <a target='new' href='https://github.com/dresende/node-orm2'>node-orm2</a>, поддерживающая работу нескольких наиболее
        |  популярных СУБД, в том числе PostrgreSQL и MySQL. Вы можете обратиться к <a target='new' href='https://github.com/dresende/node-orm2/wiki'>документации</a> данного ORM,
        |  чтобы разобраться с особенностями его работы. Однако, здесь и далее в рамках туториала я настоятельно рекомендую использовать MongoDB, так как это значительно упростит
        |  процесс знакомства с библиотекой. Если Вы правильно настроили базу данных и не меняли конфигурационные файлы проекта, создаваемые в проекте модели будут автоматически отображаться
        |  на текущую используемую базу данных и не потребуют дополнительных действий.
p Серверная часть Muon определяет единственную глобальную переменную <strong>m</strong>, которая доступна в любом месте в рамках проекта. <strong>m</strong> является простым объектом, включающим в себя
  |  набор членов, ссылающихся на различные структурные элементы сервера. В текущий момент нас интересует атрибут <strong>models</strong>, который, как можно догадаться,
  |  содержат в себе словарь объявленных моделей:
pre.prettyprint.lang-js foo$ m-console<br>
    |  > <strong>m.utils._.keys(m.models)</strong><br>
    |  ["note","user"]<br>
    |  > <strong>m.models["note"]</strong><br>
    |  { [Function]<br>
    |      allProperties:<br>
    |      { created_at:<br>
    |          { type: 'date',<br>
    |            time: true,<br>
    |            klass: 'primary' },<br>
    |        modified_at:<br>
    |            { type: 'date',<br>
    |                time: true,<br>
    |                klass: 'primary' },<br>
    |        _id:<br>
    |            { type: 'serial',<br>
    |                rational: 'false',<br>
    |                key: true,<br>
    |                klass: 'key' } },<br>
    |  ...
p Muon как и любой другой Node.js проект обладает рядом зависимостей, среди которых есть библиотека <a target='new' href='http://underscorejs.org'>underscore</a>.
  |  Для того, чтобы упростить доступ к наиболее востребованным функциям данной библиотеки, она была включена в состав переменной <strong>utils</strong> корневого объекта <strong>m</strong>.
  |  Так с ее помощью в первой команде <strong>m.utils._.keys(m.models)</strong> мы формируем массив ключей переменной объекта <strong>m.models</strong>. Вывод следующей команды указывает
  |  на содержание модели <strong>note</strong>, и в частности на переменную <strong>allProperties</strong>, которая хранит перечень объявленных атрибутов модели. Не смотря на то, что файл с
  |  дескриптором модели заметок остался незаполненным, можно видеть, что модель уже в начальном состоянии включает несколько исходных служебных атрибутов:
ul
    li
        strong _id
        |  - уникальный идентификатор объекта модели, стандартный общепринятый атрибут всех записей баз данных;
    li
        strong created_at
        |  - атрибут временная метка, ссылающаяся на момент первого сохранения модели в БД, неизменяемая в течение всего времени жизни объекта;
    li
        strong modified_at
        |  - атрибут временная метка, ссылающаяся на момент последней модификации объекта модели, устанавливается автоматически непосредственно перед сохранением модели в базу данных.
p Создать новый экземпляр модели заметки можно, вызвав метод <strong>create</strong соответствующего класса:
pre.prettyprint.lang-js
    |  > var Note = m.models.note;<br>
    |  > var n1 = Note.create();<br>
    |  > n1<br>
    |  { created_at: [Getter/Setter],<br>
    |      modified_at: [Getter/Setter],<br>
    |      _id: [Getter/Setter],<br>
    |  > n1.created_at<br>
    |  null<br>
    |  > n1.save()<br>
    |  ...<br>
    |  > n1.created_at<br>
    |  Thu Jan 28 2014 15:34:07 GMT+0400 (MSK)<br>
    |  > n1._id<br>
    |  '52e0fe2ff75974be11de9427'<br>
p Из вывода видно, как после вызова созданного экземпляра модели ему был присвоен атрибут <strong>_id</strong>, который имеет формат стандартного объекта <strong>ObjectId</strong> MongoDB.
div.mark
    h6 Model vs. ORM
    p Формально, то что мы называем моделью на стороне сервера является лишь прослойкой между интерпретатором и базой данных, позволяющей с помощью унифицированных
        |  команд контролировать содержание соответствующей коллекции (таблицы) в базе, а также преобразовывать табличную (реляционную) форму записей в объектную
        |  (естественную для JavaScript). Последнее относится к случаю с использованием SQL-баз, и соответствующий механизм называется <strong>ORM</strong> (<strong>Object-Relational Mapping</strong>,
        |  в случае для NoSQL баз - <strong>ODM</strong>, <strong>Object-Document Mapping</strong>). Модели Muon реализованы на базе ORM/ODM (далее везде ORM) библиотеки
        |  <a target='new' href='https://github.com/dresende/node-orm2'>node-orm2</a>, которая предоставляет набор методов для доступа к записям из БД и их фильтрации.
p Для работы с объектами моделей соответствующие классы предоставляют целый ряд методов, таких как <strong>find</strong>, <strong>get</strong>, <strong>filter</strong>, <strong>sort</strong>, <strong>limit</strong> и т.д.
    |  Так например, чтобы получить список всех доступных объектов заметок, следует выполнить следующую команду:
pre.prettyprint.lang-js
    |  > m.models.note.find({},function(err,arr){<br>
    |  ...  console.log(JSON.stringify(arr));<br>
    |  ... });<br>
    |  [{<br>
    |      "created_at":"2014-01-28T15:34:07.651Z",<br>
    |      "modified_at":"2014-01-28T15:34:07.651Z",<br>
    |      "_id":"52e0fe2ff75974be11de9427",<br>
    |   }]
p Все методы эти методы в большинстве своем работают, используя классический механизм обратных вызовов (callback), где колбэк-метод передается
    |  в качестве последнего аргумента и сам принимает два параметра: объект ошибки и результат.
p Любая модель (как и любой пользовательский класс) характеризуется набором описывающих ее атрибутов, а также взаимных ассоциаций. Наш случай
    |  достаточно прост, поэтому мы сразу можем принять, что модель <strong>заметки</strong> будет включать в себя заголовок, данные текста, временной таймштамп,
    |  а также будет ссылаться на пользователя, создавшего данную заметку. Модель пользователя будет характеризоваться единственным атрибутом -
    |  ключом доступа, который будет сохранен в Cookie-переменной на стороне клиента.
div.tutor-img(style='padding: 0 150px')
    img(data-src='model_relations.png')


