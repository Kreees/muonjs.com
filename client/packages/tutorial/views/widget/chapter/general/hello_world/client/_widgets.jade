h5.title#widgets Виджеты
p Мы наконец подошли к основному моменту в разработке клиента - созданию виджетов. Фактически мы уже занимались
    |  созданием виджетов, когда добавляли новые страницы в клиент. Прежде чем мы продолжим, мне нужно сделать
    |  несколько замечаний касательно терминологии.
p Формально все, что создано в директории <strong>views</strong> пакета, считается виджетом, включая
    |  <strong>application_stack</strong> и страницы. В то же время, в предыдущей главе я указал, что в папке <strong>views</strong>
    |  может находиться лишь пять папок, соответствующих названиям объявленных типов виджетов, среди которых также
    |  присутствует название <strong>widget</strong>. Слово <strong>view</strong> с английского переводится как <strong>представление</strong>, что общепринято в веб-разработке.
    |  В тоже время термин <strong>представление</strong> взят из аббревиатуры <a href='http://en.wikipedia.org/wiki/Model_View_Controller' target='new'>MVC (Model, View, Controller)</a>
    |  и имеет прямое отношение к отображению данных моделей, что не совсем корректно по отношению к элементам интерфейса, так
    |  некоторые из них не имеют прямого отношения к данным и имеют в большей степени функциональное или структурное назначение,
    |  например <strong>лэйауты</strong> (<strong>layouts</strong>). Все это может показаться крайне запутанным, и по этой причине, чтобы избавить
    |  Вас от лишней головной боли в дальнейшем, мы примем несколько соглашений относительно того, что и как называть.
ul
    li Собственно, все элементы интерфейса вне зависимости от их назначения в данном туториале я называю <a href='http://en.wikipedia.org/wiki/GUI_widget' target='new'>виджетами</a> или представлениями.
    li  Среди всех виджетов присутствует пять типов: лэйауты, модели, коллекции, стэки и виджеты. <strong>Тип виджет</strong> - является наиболее общим и самым
        |  простым типом представлений (все остальные типы обладают функцоналом обычных виджетов).
    li Исходный код виджетов (представлений) размещен в директории <strong>views</strong> пакета - это в большей степени дань моде в веб-разрботке.
    li В процессе программирования на JavaScript Вы будете создавать виджеты, используя соответствующие классы: <strong>m.View</strong>,
        |  <strong>m.WidgetView</strong>, <strong>m.LayoutView</strong>, <strong>m.PageLayoutView</strong> и т.д. Сами классы
        |  наследованы от класса <strong>Backbone.View</strong> библиотеки <a target='new' href='http://backbonejs.org'>Backbone</a>, лежащей в основе Muon, и используют
        |  аналогичное название.
p Пока мы начнем с разрботки обычных виджетов, так как они несут в себе весь базовый функционал представлений.
    |  Как мы уже знаем, создание виджетов сводится к созданию соответствующей директории в одной исходных подпапок представлений (в нашем случае
    |  <strong>/views/widget</strong>) и описанию трех его составляющих: верстки, логики и внешнего вида.
div.tutor-img(style='padding: 0 100px')
    img(data-src='js_css_html.png')
p Формально, любая (но не все сразу!) из этих частей может отсутствовать - в этом случае она замещается стандартным элементом:
    |  в случае верстки - это пустой тэг (по-умолчанию DIV), для логики - это стандартный класс соответствующего типа (например, m.WidgetView),
    |  стили в данном случае просто отстутствуют.
p Для того, чтобы обращаться к виджетам в процессе создания приложения, требуется какой-то механизм их именования. В Muon
    |  имя виджета включает в себя две составляющие - непосредственное имя и тип. Непосредственное имя виджета соответствует
    |  его пути относительно базовой директории, в то время как тип - названию этой директории. Так, например, виджет размещенный в
    |  директории <strong>/views/widget/widget/super/some/</strong> будет иметь имя <strong>some_super_widget</strong> и тип <strong>widget</strong>.
    |  Другой пример - директория <strong>/views/layout/page/message/send/</strong> будет соответствовать <strong>layout</strong>-виджету
    |  с именем <strong>send_message_page</strong>.
p Чтобы в процессе создания виджета мы могли автоматически отслеживать его изменения в браузере, нам необходимо разместить
    |  его на одной из наших созданных страниц (например, на главной - <strong>index_page_layout</strong>). Для помещения одних виджетов
    |  в другие библиотека предоставляет несколько различных механизмов, но самый простой из них - это декларация виджета с помощью
    |  верстки. В частности с помощью такой записи:
tag = "<div data-widget-view='some_widget' />"
pre.prettyprint.lang-html= tag
p мы можем разместить виджет <strong>some_widget</strong> в любом месте нашего приложения. В процессе формирования (<strong>рендеринга</strong>) каждое представление анализурет
    |  содержание собственной верстки и размещает в соответствующих тэгах другие представления, что избавляет нас от необходимости
    |  делать это вручную в JavaScript коде.
p Начнем мы с простого примера - наш виджет будет представлять собой две кнопки, по нажатию одной из которых будет всплывать alert box с
    |  сообщением "Hello, world!", по нажатию второй - виджет сам себя удалит. Для этого на странице <strong>index_page</strong> необходимо добавить тэг аналогично тому,
    |  как это было сделано выше:
p: strong /client/packages/application/layout/page/index/index.html:
title = "<h1>Welcome to the Super Calendar</h1>"
data = "<p>This is the main page of the Calendar</p>"
widget = "<div data-widget-view='alertBox' />"
pre.prettyprint.lang-html
    = title
    br
    = data
    br
    = widget
p Перезагрузив страницу, мы не увидим ничего, кроме ошибки в консоли об отсутствующем представлении.
    |  Исправим это, создав файл с описанием верстки нашего виджета:
p: strong /client/packages/application/widget/alertBox/box.html
but = "<button id='press'>Press me!</button>"
but_remove = "<button id='remove'>Remove me!</button>"
pre.prettyprint.lang-html
    = but
    br
    = but_remove
p Если мы вновь перезагрузим страницу, то увидим на месте, где мы указали блок <strong>DIV</strong> с атрибутом
    |  <strong>data-widget-view</strong>, кнопки нашего виджета:
div.tutor-img.shadow
    img(data-src='main_page_but_added.png')
p Разместить виджет данным образом мы можем в любом месте приложения любое количество раз, библиотека это допускает,
    |  хотя особого смысла в этом нет.
p Существуют ситуации, когда виджет не предполагает взаимодействия с другими виджетами и не несет в себе какой либо
    |  функцониальности, кроме пассивного отображения данных верстки (это справедливо, например, для страниц данного туториала).
    |  Однако, в большинстве случаев Вам всеже потребуется возможность активного взаимодействия виджетов как с пользователем,
    |  так и друг с другом. Для этого виджет должен обладать определенным функциональным интерфейсом, а также способностью,
    |  обрабатывать внешние асинхронные события.
p Вполне очевидно, описание программного интерфейса для нашего виджета должно быть помещено в файл <strong>/views/widget/alertBox/box.js</strong>.
    |  Данный файл должен содержать в себе объвление нового класса виджетов, которое происходит за счет расширения одного из уже существующих классов представлений.
    |  Так например, для создания нового класса представлений типа "виджет" необходимо наследовать уже объявленный класс <strong>m.WidgetView</strong>.
    |  С учетом того, что язык JavaScript не предусматривает прямого механизма наследования (принятого в общераспространенных объектро-ориентированных языках),
    |  наследование в данном случае осуществляется через специальных метод <strong>extend</strong>, которым обладают все существующие и вновь создаваемые классы виджетов.
    |  Выглядеть это должно следующим образом:
pre.prettyprint.lang-js
    |  m.WidgetView.extend({<br>
    |       init: function(){ ... },<br>
    |       rendered: function(){ ... },<br>
    |       events: { ... },<br>
    |       removed: function(){ ... },<br>
    |  });<br>
div.mark
    h5 Muon vs. Backbone
    p Механизм наследования в даном случае перенесен из библиотеки <strong>Backbone</strong>, где для объявления нового типа представления
        |  также используется метод <strong>Backbone.View.extend</strong>. Общее поведение, присущее представлениям Backbone перенесено с небольшими
        |  изменениями в библиотеку Muon. В тоже время виджеты Muon реализуют целый комплекс мер, позволяющих лучше контролировать жизненный цикл
        |  создаваемых экземпляров виджетов, а также совмещать их с другими подсистемами фреймворка. Базовый функционал виджетов, перенесенный в Muon из
        |  библиотеки Backbone, описан в соответствующей разделе <a target='new' href='http://backbonejs.org/#View'>документации</a>
p Подробно интерфейс виджетов будет рассмотрен в соответствующих главах туториала, а пока рассмотрим возможность перехвата пользовательских событий
    |  в нашем <strong>AlertBox</strong>'е. За объявление обработчиков событий (вне зависиомости от типа), отвечает атрибут <strong>events</strong>.
    |  Он представлят из себя объект (словарь), ключом которого является указание события и селектор, по отношению к которому это событие применяется.
    |  Значением данного атрибута является либо непосредственно метод, его обрабатывающий, либо имя метода, принадлежащего данному виджету.
    |  В нашем случае описание виджета будет выглядеть следующим образом:
p: strong /client/packages/applciation/views/widget/alertBox/box.js
pre.prettyprint.lang-js
    |  m.WidgetView.extend({<br>
    |       events: {<br>
    |           "click button#press" : function(){ alert("Hello, World!"); },<br>
    |           "click button#remove" : "remove"<br>
    |       }<br>
    |  });<br>
p Вновь перезагрузив страницу, мы можем опробовать наш виджет: по нажатию на кнопку с надписью 'Press Me!' должно появиться alert уведомление.
div.tutor-img.shadow
    img(data-src='alert_popup.png')
p Нажав на кнопку с надписью 'Remove Me' оба тэга <strong>button</strong> будут удалены из документа.
p Напоследок следует сказать, что путем регистрации событий через атрибут <strong>events</strong>, можно перехватывать
    |  произвольные события, в том числе не являющиеся <strong>DOM</strong>. Реализация обработки событий в Muon
    |  происходит с помощью средств библиотеки <a target='new' href='http://jquery.com'>jQuery</a>, с который должно быть знакомо
    |  подавляющее большинство JavaScript-программистов. По этой причине виджеты имеют возможность обрабатывать как стандартные события
    |  браузера, так и нестандартные пользовательские события, в том числе испускаемые другими виджетами. О том как их использовать мы поговорим в следующих главах.
p На данном этапе мы приостановим наше знакомство с виджетами и работой клиента в целом. Следующим шагом для нас будет работа с пользовательскими
    |  данными через виджеты моделей данных и коллекций, а также взаимодействие с сервером. Но, прежде чем преступить к этому этапу, нам необходимо
    |  познакомиться с основными принципами работы сервера, а также протоколом взаимодействия сервера и клиента.
